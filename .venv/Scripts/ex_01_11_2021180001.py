coords = [

(620, 332), (784, 623), (182, 555), (1413, 451), (1092, 660),

(30, 217), (525, 148), (1311, 887), (1228, 353), (54, 68),

(1155, 838), (467, 563), (86, 535), (32, 630), (739, 766),

(1386, 16), (1565, 828), (868, 264), (1301, 786), (883, 415),

(479, 534), (1101, 35), (671, 405), (1478, 230), (1343, 834),

(647, 97), (972, 447), (327, 334), (716, 151), (233, 411),

(486, 431), (1017, 381), (329, 830), (1286, 739), (1528, 248),

(216, 294), (1306, 540), (204, 715), (77, 120), (97, 178),

(809, 28), (354, 205), (123, 551), (248, 828), (888, 139),

(594, 494), (576, 702), (64, 218)

]
#from math import sqrt

#nlogn

def distance(a, b):
    d=(b[0]-a[0])**2+(b[1]-a[1])**2

def brute_force(arr, i1, i2):
    pass

def devide_and_conquer(arr, i1, i2):

    '''배열의 사이즈를 확인해 1일경우 거리 X<<호출되는 일 없음
    2일 경우 두 점의 거리 return
    3읽경우 bruteforce
    4 이상일 경우 x의 값을 기준으로 정렬
    정렬 방법 1: coords에 sort 사용'''

    '''X좌표: 중간점X좌표-d~중간점x좌표+d
    index1: x좌표가 -d이상인 점들중 가장 왼쪽index
    index2: // +d 이하인 점들중 가장 오른쪽index
    strip=[t for t in y_sorted if t[2] >= index1 and t[2] <= index2]
    '''


    pass
coords.sort(key=lambda x: x[0])
x_sorted=[(coords[i][0], coords[i][1], i) for i in range(len(coords))]
print(x_sorted)
y_sorted=sorted(x_sorted, key=lambda x: x[1])#x좌표로 정렬되어 있는 coords의 인덱스를 유지하며 y로 정렬
print(y_sorted)